# Streams & Lambdas

![streams-lambdas-main](media/streams-lambdas-main.jpg)

[#half-life-3-confirmed](https://kotaku.com/tag/half-life-3)

# Introduction

Before jumping into conclusions and start bragging about how Streams and Lambdas are going to suddenly solve all our problems let's start by ... doing some code-work.

We will write a method that takes a `List<Manager>` as input and then groups every manager by his/her department, resulting in a `Map<String, List<Manager>>`. 

For reference the `Manager` class looks like:

```java
@Data // Getters and setters are generated by project lombok
@NoArgsConstructor // No Args constructor is generated by project lombok
@AllArgsConstructor // All Args constructor is generated by project lombok
private class Manager {
    private Long id;
    private String name;
    private String department;
}
```

Normally (if normally means not using lambdas & streams) we would do something like this:

```java
public static Map<String, List<Manager>> groupByDepartments(List<Manager> managers) {
        Map<String, List<Manager>> result = new HashMap<>();
        for(Manager manager : managers) {
            result.putIfAbsent(manager.getDepartment(), new LinkedList<>());
            result.get(manager.getDepartment()).add(manager);
        }
        return result;
}
```

This doesn't look too bad, and the code is quite straight-forward. We can live with that.

But what if tell you `groupingBy` is a thing that is "built-in" in the Stream API and everything becomes:

```java
public static Map<String, List<Manager>> groupByDepartmentsF(List<Manager> managers) {
        return managers.stream().collect(groupingBy(Manager::getDepartment));
}
```








